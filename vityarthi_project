#code1 

import psutil, os

process = psutil.Process(os.getpid())
print(f"Memory usage: {process.memory_info().rss} bytes")  

import time

start = time.perf_counter()   

def euler_phi(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    count = 0
    for k in range(1, n + 1):
        a,b = n, k
        while b:
            a, b = b, a % b
        if a == 1:
            count += 1
    return count
if _name_ == "_main_":
    n = int(input("Enter a positive integer: "))
    print("Euler's Totient function for", n, "is", euler_phi(n))

end = time.perf_counter() 


print("Execution time:", end - start, "seconds")


#code2

import psutil, os

process = psutil.Process(os.getpid())
print(f"Memory usage: {process.memory_info().rss} bytes")  

import time

start = time.perf_counter()  
def mobius(n):
    if n == 1:
        return 1

    factors = 0
    i = 2
    while i * i <= n:
        if n % i == 0:
            if (n // i) % i == 0:
                return 0
            factors += 1
            n = n // i
            while n % i == 0:
                n = n // i
        i += 1

    if n > 1:
        factors += 1

    if factors % 2 == 0:
        return 1
    else:
        return -1

n = int(input("Enter a positive integer: "))
print("Mobius function for", n, "is", mobius(n))

end = time.perf_counter() 


print("Execution time:", end - start, "seconds")


#code3

import psutil, os

process = psutil.Process(os.getpid())
print(f"Memory usage: {process.memory_info().rss} bytes")  
import time

start = time.perf_counter()  

def divisor_sum(n):
    total = 0
    i = 1
    while i <= n:
        if n % i == 0:  
            total = total + i
        i = i + 1
    return total


n = int(input("Enter a positive integer: "))
print("Sum of divisors of", n, "is", divisor_sum(n))

end = time.perf_counter() 


print("Execution time:", end - start, "seconds")

#code4

import psutil, os

process = psutil.Process(os.getpid())
print(f"Memory usage: {process.memory_info().rss} bytes")  
import time

start = time.perf_counter()   
def prime_pi(n):
    count = 0
    num = 2   

    while num <= n:
        is_prime = 1   
        divisor = 2
        while divisor * divisor <= num:   
            if num % divisor == 0:
                is_prime = 0
                break
            divisor = divisor + 1
        if is_prime == 1:
            count = count + 1
        num = num + 1

    return count

n = int(input("Enter a positive integer: "))
print("Number of primes up to", n, "is", prime_pi(n))
end = time.perf_counter() 
print("Execution time:", end - start, "seconds")

#code5

import psutil, os

process = psutil.Process(os.getpid())
print(f"Memory usage: {process.memory_info().rss} bytes")  

import time

start = time.perf_counter()  
def legendre_symbol(a, p):
    if a % p == 0:
        return 0

    exp = (p - 1) // 2
    result = 1
    base = a % p

    while exp > 0:
        if exp % 2 == 1:       
            result = (result * base) % p
        base = (base * base) % p
        exp = exp // 2

    if result == 1:
        return 1
    elif result == p - 1:
        return -1
    else:
        return 0   
    print(f"Legendre symbol ({a}/{p}) =", legendre_symbol(a, p))
n = int(input("Enter a positive integer a: "))
p = int(input("Enter a prime number p: "))
print(f"Legendre symbol ({n}/{p}) =", legendre_symbol(n, p))

end = time.perf_counter() 


print("Execution time:", end - start, "seconds")

'''1st program'''

import time
import tracemalloc

tracemalloc.start()
ST=time.time()

def factorial(n):
    if n<0:
        print("Factorial is not defined for negative numbers")
    elif n==0:
        return 1
    else:
        value=1
        for i in range(1,n+1):
            value*=i
        return value


x=-2
result=factorial(x)
y=24
result1=factorial(y)
print (f" The factorial of {y} is {result1} ")

ET=time.time()
duration=ET-ST
current, peak = tracemalloc.get_traced_memory()
print(f" The total duration of the program is:{duration} seconds")
print(f" The total memory used is:{peak} bytes")


''' 2nd program '''
import time
import tracemalloc

tracemalloc.start()
ST=time.time()


def is_palindrome(num):

    if num<0:
        return False
    elif num==0:
        return True

    original=num
    reverse=0

    while num>0:
        digit=num%10
        reverse=reverse*10+digit
        num //=10
        if original==reverse:
            return True
         

    

print(f"121 is a palindrome: {is_palindrome(121)}")
print(f"123 is a palindrome: {is_palindrome(123)}")
print(f"-121 is a palindrome: {is_palindrome(-121)}")
print(f"0 is a palindrome: {is_palindrome(0)}")

ET=time.time()
duration=ET-ST
current, peak = tracemalloc.get_traced_memory()
print(f" The total duration of the program is:{duration} seconds")
print(f" The total memory used is:{peak} bytes")


'''3rd program'''
import time
import tracemalloc

tracemalloc.start()
ST=time.time()

def mean_of_digits(n):
    digiSum, digiLen = 0, 0

    while n:
        digiLen += 1
        digiSum += n % 10
        n = n//10
    return(digiSum/digiLen)

print (" The average of digits is:",mean_of_digits(567))
print (" The average of digits is:",mean_of_digits(76547))

ET=time.time()
duration=ET-ST
current, peak = tracemalloc.get_traced_memory()
print(f" The total duration of the program is:{duration} seconds")
print(f" The total memory used is:{peak} bytes")


''' 4th program'''

import time
import tracemalloc

tracemalloc.start()
ST=time.time()

def digital_root(n):
    if n < 0:
        raise ValueError("Input must be a non-negative integer.")

    while n >= 10:
        add = 0
        while n > 0:
            add += n % 10  
            n //= 10              
        n = add
    return n

print("The digital root is:",digital_root(1234))
print("The digital root is:",digital_root(3436))

ET=time.time()
duration=ET-ST
current, peak = tracemalloc.get_traced_memory()
print(f" The total duration of the program is:{duration} seconds")
print(f" The total memory used is:{peak} bytes")


''' 5th program '''
import time
import tracemalloc

tracemalloc.start()
ST=time.time()

def  is_abundant(n):
     if n < 1:
        return False

     add = 0
    
     for i in range(1, n):
        if n % i == 0:
            add += i

     return add > n

print(is_abundant(12))  
print(is_abundant(17))  
print(is_abundant(13))

ET=time.time()
duration=ET-ST
current, peak = tracemalloc.get_traced_memory()
print(f" The total duration of the program is:{duration} seconds")
print(f" The total memory used is:{peak} bytes")      

#code1

import math

def is_deficient(n):
    
    if n <= 0:
        return False
        
    sum_of_divisors = 1  
    for i in range(2, int(math.sqrt(n)+1)):
        if n % i == 0:
            sum_of_divisors += i
            if i * i != n:
                sum_of_divisors += n // i
    
    return sum_of_divisors < n

        
          
print(is_deficient(6))
print(is_deficient(8))
print(is_deficient(95))


#code2

def is_harshad(n):
  
  if n <= 0:  
    return False

  sum_of_digits = 0
  x = n
  while x > 0:
    sum_of_digits += x % 10  
    x //= 10  

 
  return n % sum_of_digits==0


print(is_harshad(12))
print(is_harshad(15))


#code3

def is_automorphic(n):

    if n < 0:
        print("Enter positive number")

    square = n * n
  
  
    x = str(n)
    y = str(square)

  
    if y.endswith(x):
        return True
    else:
        return False
        

print(is_automorphic(1))
print(is_automorphic(12))
print(is_automorphic(6))


#code4

import math

def is_pronic(n):
   
    
    if n < 0:
        return False  
    
    
    for i in range(0,n): 
        if i * (i + 1) == n:
            return True
    else:
        return False

print(is_pronic(6))
print(is_pronic(4))
print(is_pronic(42))
print(is_pronic(30))


#code5

def prime_factors(n):

    
    i = 2

    while i * i <= n:
      while n % i == 0:
        print(i)
        n //= i
      i += 1

    if n > 1:
        print(n)

      
print(prime_factors(35))
print(prime_factors(315))
print(prime_factors(6))
print(prime_factors(18))

#code1

def count_distinct_prime_factors(n):
    if n < 2:
        raise ValueError
    
    count = 0
    temp = n
    

    if temp % 2 == 0:
        count += 1
        while temp % 2 == 0:
            temp //= 2
    

    factor = 3
    while factor * factor <= temp:
        if temp % factor == 0:
            count += 1
            while temp % factor == 0:
                temp //= factor
        factor += 2
    
    if temp > 1:
        count += 1
    
    return count
print(count_distinct_prime_factors(2310)) 


#code2

def is_prime_power(n):
    
    if n < 2:
        raise ValueError("Input must be a positive integer greater than 1")
    
    max_exponent = n.bit_length()  
    for k in range(1, max_exponent + 1):
        
        root = round(n ** (1 / k))
        
    
        for candidate in [root - 1, root, root + 1]:
            if candidate < 2:
                continue
            power = candidate ** k
            if power == n and is_prime(candidate):
                return True
    
    return False

def is_prime(num):
    
    if num < 2:
        return False
    if num == 2:
        return True
    if num % 2 == 0:
        return False
    
    for i in range(3, int(num**0.5) + 1, 2):
        if num % i == 0:
            return False
    return True
print(is_prime_power(27)) 


#code3

def is_mersenne_prime(p):

    if p < 2:
        raise ValueError("Input p must be at least 2")
    
    mersenne = 2**p - 1
    
    known_mersenne_primes = {2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127}
    if p in known_mersenne_primes:
        return True
    
    return is_prime_mersenne(mersenne)

def is_prime_mersenne(n):
   
    if n < 2:
        return False
    if n == 2:
        return True
    if n % 2 == 0:
        return False
    
    limit = int(n**0.5) + 1
    
    k = 1
    divisor = 2 * k * (n.bit_length()) + 1  
    
    while divisor <= limit:
        if n % divisor == 0:
            return False
        k += 1
        divisor = 2 * k * (n.bit_length()) + 1
    
    return True
print(is_mersenne_prime(7))


#code4

def twin_primes(limit):
    

    if limit < 3:
        raise ValueError("Limit must be at least 3")
    
    
    primes = sieve_of_eratosthenes(limit)
    
    
    twin_pairs = []
    for i in range(len(primes) - 1):
        if primes[i + 1] - primes[i] == 2:
            twin_pairs.append((primes[i], primes[i + 1]))
    
    return twin_pairs

def sieve_of_eratosthenes(n):
   
    if n < 2:
        return []
    
    sieve = [True] * (n + 1)
    sieve[0] = sieve[1] = False
    
    for i in range(2, int(n**0.5) + 1):
        if sieve[i]:
            sieve[i*i : n+1 : i] = [False] * len(sieve[i*i : n+1 : i])
    
    return [i for i, is_prime in enumerate(sieve) if is_prime]
print("Twin primes up to 20:")
print(twin_primes(20))


#code5

def count_divisors(n):
    if n <= 0:
        raise ValueError("Input must be a positive integer")
    
    if n == 1:
        return 1
    
    count = 1  
    i = 2
    while i * i <= n:
        if n % i == 0:

            if i * i == n:
                count += 1  
            else:
                count += 2  
        i += 1
    
    return count + 1
print(f"d(12) = {count_divisors(12)}")

#code1

import time
st=time.perf_counter()
def aliquot_sum(n):

   
  if  n <= 0:
    return "enter a positive integer"
  
  x = 0
 
  for i in range(1, n // 2 + 1):
    if n % i == 0:
      x += i
      
  return x


st=time.perf_counter()
print(aliquot_sum(12)) 
print(aliquot_sum(6))  
print(aliquot_sum(1))   
et=time.perf_counter() 
execution_time =et-st
print("Execution time:",execution_time)


#code2

import time

def are_amicable(a,b):
     if a<0:
         return "enter a positive number"

     x=0
     for i in range (1,a//2+1):
         if a % i ==0:
             x+=i
         if x==b:
             return True

st=time.perf_counter()
print(are_amicable(84,20))
print(are_amicable(7,8))
print(are_amicable(220,284))
et=time.perf_counter()
duration=et-st
print("duration:",duration)


#code3

import time

def multiplicative_persistence(n):
    if n <10:
        return 0


    persistence=0
    number=n

    while number>=10:
        product=1
        for i in str(number):
            product *= int(i)
        number= product
        persistence += 1

    return persistence


st=time.perf_counter()
print(multiplicative_persistence(78))
print(multiplicative_persistence(888))
print(multiplicative_persistence(4))
et=time.perf_counter()
duration=et-st
print("duration:",duration)


#code4

import math
import time


def count_divisors(num):
  
    if num <= 0:
        return 0
    divisor_count = 0
    for i in range(1, int(math.sqrt(num) + 1)):
        if num % i == 0:
            if num / i == i:  
                divisor_count += 1
            else:
                divisor_count += 2
    return divisor_count

def is_highly_composite(n):
  
    if n <= 0:
        return False
        
    original_divisor_count = count_divisors(n)
    
  
    for i in range(1, n):
        if count_divisors(i) >= original_divisor_count:
            return False 
            
    return True  


st=time.perf_counter()
print(is_highly_composite(1))
print(is_highly_composite(6))
print(is_highly_composite(7)) 
et=time.perf_counter()
duration=et-st
print(f"Execution time: {duration:.6f} seconds")


#code5

import time

def mod_exp(base, exponent, modulus):
    
    if modulus == 1:
        return 0  

    result = 1
    base %= modulus  

    while exponent > 0:
        
        if exponent % 2 == 1:
            result = (result * base) % modulus

        
        base = (base * base) % modulus

       
        exponent //= 2
    

    return result



st=time.perf_counter()
base1 = 2
exponent1 = 3
modulus1 = 5
result1 = mod_exp(base1, exponent1, modulus1)
print(f"({base1}^{exponent1}) % {modulus1} = {result1}")
et=time.perf_counter()
duration=et-st
print(f"Execution time: {duration:.6f} seconds")

#code1

import time
import tracemalloc

def extended_gcd(a, b):
    old_r, r = a, b
    old_s, s = 1, 0
    old_t, t = 0, 1

    while r != 0:
        q = old_r // r
        old_r, r = r, old_r - q * r
        old_s, s = s, old_s - q * s
        old_t, t = t, old_t - q * t

    return old_r, old_s, old_t   

def mod_inverse(a, m):
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        return None              
    return x % m                 

a = 3
m = 11

print(f"\nFinding modular inverse of {a} mod {m}...\n")
tracemalloc.start()
t0 = time.perf_counter()

inverse = mod_inverse(a, m)

elapsed = time.perf_counter() - t0
current, peak = tracemalloc.get_traced_memory()
tracemalloc.stop()

if inverse is None:
    print(f"No modular inverse exists because gcd({a}, {m}) ≠ 1.")
else:
    print(f"Modular Multiplicative Inverse: {inverse}")
    print(f"Check: ({a} * {inverse}) % {m} = {(a * inverse) % m}")

print("\n--- Performance Stats ---")
print(f"Time taken        : {elapsed:.8f} seconds")
print(f"Memory (current)  : {current} bytes")
print(f"Memory (peak)     : {peak} bytes")



#code2

import time
import tracemalloc
import math
from typing import List, Optional, Tuple


def extended_gcd(a: int, b: int) -> Tuple[int, int, int]:
    old_r, r = a, b
    old_s, s = 1, 0
    old_t, t = 0, 1
    while r != 0:
        q = old_r // r
        old_r, r = r, old_r - q * r
        old_s, s = s, old_s - q * s
        old_t, t = t, old_t - q * t
    return old_r, old_s, old_t


def mod_inverse(a: int, m: int) -> Optional[int]:
    gcd, x, _ = extended_gcd(a, m)
    if gcd != 1:
        return None
    return x % m


def pairwise_coprime(moduli: List[int]) -> bool:
    n = len(moduli)
    for i in range(n):
        for j in range(i + 1, n):
            if math.gcd(moduli[i], moduli[j]) != 1:
                return False
    return True


def crt(remainders: List[int], moduli: List[int]) -> Tuple[Optional[int], Optional[int], dict]:
    if len(remainders) != len(moduli) or len(moduli) == 0:
        raise ValueError("remainders and moduli must be non-empty lists of the same length.")

    if not pairwise_coprime(moduli):
        return None, None, {"error": "Moduli are not pairwise coprime."}

    M = 1
    for m in moduli:
        if m <= 0:
            return None, None, {"error": f"Invalid modulus {m}; moduli must be positive integers."}
        M *= m

    debug = {"M": M, "terms": []}
    total = 0

    for i, (r_i, m_i) in enumerate(zip(remainders, moduli)):
        M_i = M // m_i                        
        inv = mod_inverse(M_i, m_i)          
        if inv is None:
            return None, M, {"error": f"No inverse for M_i mod m_i (i={i}): gcd({M_i}, {m_i}) != 1"}
        term = (r_i * M_i * inv) % M          
        debug["terms"].append({
            "index": i,
            "r_i": r_i,
            "m_i": m_i,
            "M_i": M_i,
            "inv_Mi_mod_mi": inv,
            "term_mod_M": term
        })
        total = (total + term) % M

    result = total % M
    return result, M, debug


def human_readable_bytes(n: int) -> str:
    for unit in ("B", "KB", "MB", "GB"):
        if n < 1024.0:
            return f"{n:.0f} {unit}"
        n /= 1024.0
    return f"{n:.2f} TB"


if _name_ == "_main_":
    remainders = [2, 3, 2]   # r1, r2, r3
    moduli      = [3, 5, 7]  # m1, m2, m3

    print("Solving the system of congruences:")
    for r, m in zip(remainders, moduli):
        print(f"  x ≡ {r} (mod {m})")
    print("\n------------------------------\n")

    tracemalloc.start()
    t0 = time.perf_counter()

    result, M, debug = crt(remainders, moduli)

    elapsed = time.perf_counter() - t0
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    if result is None:
        print("CRT failed:")
        if debug and "error" in debug:
            print("  Error:", debug["error"])
        else:
            print("  Unknown error.")
    else:
        print(f"The unique solution is: x ≡ {result} (mod {M})\n")
        print("Verification (each congruence):")
        for t in debug["terms"]:
            idx = t["index"]
            r_i = t["r_i"]
            m_i = t["m_i"]
            check = result % m_i
            print(f"  eq {idx+1}: x % {m_i} = {check}  (expected {r_i})")

        print("\nComputation details (per term):")
        for t in debug["terms"]:
            print(f"  i={t['index']}: r_i={t['r_i']}, m_i={t['m_i']}, M_i={t['M_i']}, inv={t['inv_Mi_mod_mi']}, term={t['term_mod_M']}")

    print("\n--- Performance ---")
    print(f"Time elapsed       : {elapsed:.8f} seconds")
    print(f"Memory (current)   : {current} bytes ({human_readable_bytes(current)})")
    print(f"Memory (peak)      : {peak} bytes ({human_readable_bytes(peak)})")


#code3

import time
import tracemalloc

def modular_pow(base, exponent, modulus):
    """Efficient modular exponentiation (repeated squaring)."""
    result = 1
    base %= modulus
    while exponent > 0:
        if exponent % 2 == 1:     
            result = (result * base) % modulus
        base = (base * base) % modulus
        exponent //= 2
    return result


def quadratic_residue_check(a, p):
    """Return True if 'a' is a quadratic residue modulo prime 'p'."""
    if p <= 2 or p % 2 == 0:
        raise ValueError("Modulus p must be an odd prime.")

    a = a % p
    if a == 0:
        return True                     

    exponent = (p - 1) // 2
    result = modular_pow(a, exponent, p)

    if result == 1:
        return True
    elif result == p - 1:
        return False
    else:
        print("Warning: Unexpected Euler result.")
        return False

a = 10
p = 13
print(f"\nChecking if {a} is a quadratic residue modulo {p}...\n")

tracemalloc.start()
t0 = time.perf_counter()

try:
    is_residue = quadratic_residue_check(a, p)
except Exception as e:
    elapsed = time.perf_counter() - t0
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    print(f"Error: {e}")
    print(f"Time elapsed: {elapsed:.8f} seconds")
    print(f"Memory current: {current} bytes")
    print(f"Memory peak:    {peak} bytes")
    exit()

elapsed = time.perf_counter() - t0
current, peak = tracemalloc.get_traced_memory()
tracemalloc.stop()

if is_residue:
    print(f"Result: {a} is a Quadratic Residue modulo {p}.")
    print(f"A solution to x² ≡ {a} (mod {p}) exists.\n")
else:
    print(f"Result: {a} is a Quadratic NON-Residue modulo {p}.")
    print(f"No solution to x² ≡ {a} (mod {p}) exists.\n")

print("--- Performance ---")
print(f"Time elapsed     : {elapsed:.8f} seconds")
print(f"Memory (current) : {current} bytes")
print(f"Memory (peak)    : {peak} bytes")
print()


#code4

import time
import tracemalloc
import math
from typing import Optional, List, Tuple, Dict

def prime_factorization(n: int) -> Dict[int, int]:
    """Return prime factorization of n as {prime: exponent} using trial division."""
    factors = {}
    x = n
    while x % 2 == 0:
        factors[2] = factors.get(2, 0) + 1
        x //= 2
    f = 3
    maxf = int(math.isqrt(x)) + 1
    while f <= maxf and x > 1:
        while x % f == 0:
            factors[f] = factors.get(f, 0) + 1
            x //= f
            maxf = int(math.isqrt(x)) + 1
        f += 2
    if x > 1:
        factors[x] = factors.get(x, 0) + 1
    return factors


def euler_phi(n: int) -> int:
    if n <= 0:
        return 0
    if n == 1:
        return 1
    factors = prime_factorization(n)
    result = n
    for p in factors:
        result = result // p * (p - 1)
    return result


def divisors(n: int) -> List[int]:
    if n <= 0:
        return []
    pf = prime_factorization(n)
    divs = [1]
    for p, exp in pf.items():
        new_divs = []
        for e in range(1, exp + 1):
            mul = p ** e
            for d in divs:
                new_divs.append(d * mul)
        divs += new_divs
    return sorted(set(divs))

def multiplicative_order(a: int, n: int) -> Tuple[Optional[int], Dict]:
    debug = {"a": a, "n": n}

    g = math.gcd(a, n)
    debug["gcd"] = g
    if g != 1:
        return None, debug

    phi = euler_phi(n)
    debug["phi(n)"] = phi

    divs = divisors(phi)
    debug["divisors_of_phi"] = divs

    for d in divs:
        if pow(a, d, n) == 1:
            debug["found_d"] = d
            return d, debug
    return None, debug

if _name_ == "_main_":
    a = 2
    n = 15

    print(f"Finding multiplicative order of {a} modulo {n}...\n")

    tracemalloc.start()
    t0 = time.perf_counter()

    order, info = multiplicative_order(a, n)

    elapsed = time.perf_counter() - t0
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    if order is None:
        if info.get("gcd", None) != 1:
            print(f"Result: Order does NOT exist because gcd({a}, {n}) = {info['gcd']} ≠ 1.")
        else:
            print("Result: No order found (unexpected). Debug info:", info)
    else:
        print(f"Result: The multiplicative order of {a} modulo {n} is k = {order}.")
        print(f"Check: pow({a}, {order}, {n}) = {pow(a, order, n)}  (should be 1)\n")

        print("Extra info:")
        print(f"  gcd({a},{n}) = {info['gcd']}")
        print(f"  phi({n}) = {info['phi(n)']}")
        print(f"  divisors of phi(n) (checked): {info['divisors_of_phi']}")
        if "found_d" in info:
            print(f"  smallest d found  = {info['found_d']}")

    def nice_bytes(x):
        for unit in ("B","KB","MB","GB"):
            if x < 1024.0:
                return f"{x:.0f} {unit}"
            x /= 1024.0
        return f"{x:.2f} TB"

    print("\n--- Performance ---")
    print(f"Time elapsed       : {elapsed:.8f} seconds")
    print(f"Memory (current)   : {current} bytes ({nice_bytes(current)})")
    print(f"Memory (peak)      : {peak} bytes ({nice_bytes(peak)})")



#code5

import time
import tracemalloc
import math

def is_prime(n: int) -> bool:
    """Simple and fast primality test for n."""
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False

    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def is_fibonacci(n: int) -> bool:
    if n < 0:
        return False
    if n in (0, 1):
        return True

    f0, f1 = 0, 1
    while f1 < n:
        f0, f1 = f1, f0 + f1
    return f1 == n

n = 13
print(f"\nChecking if {n} is a Fibonacci Prime...\n")

tracemalloc.start()
t0 = time.perf_counter()

prime_status = is_prime(n)
fib_status = is_fibonacci(n)

elapsed = time.perf_counter() - t0
current_mem, peak_mem = tracemalloc.get_traced_memory()
tracemalloc.stop()
print(f"Is {n} Prime?       {prime_status}")
print(f"Is {n} Fibonacci?   {fib_status}")

if prime_status and fib_status:
    print(f"\n✔ Conclusion: {n} IS a Fibonacci Prime.\n")
else:
    print(f"\n✘ Conclusion: {n} is NOT a Fibonacci Prime.\n")

def nice_bytes(x):
    for unit in ("B", "KB", "MB", "GB"):
        if x < 1024:
            return f"{x:.0f} {unit}"
        x /= 1024
    return f"{x:.2f} TB"

print("--- Performance ---")
print(f"Time elapsed     : {elapsed:.8f} seconds")
print(f"Memory (current) : {current_mem} bytes ({nice_bytes(current_mem)})")
print(f"Memory (peak)    : {peak_mem} bytes ({nice_bytes(peak_mem)})\n")          

#code1

def lucas_sequence(n):
   
    if n <= 0:
        return  
    a, b = 2, 1

   
    if n >= 1:
        yield a
    
    
    if n >= 2:
        yield b

    
    for _ in range(2, n):
        c = a + b
        yield c
        a, b = b, c

n_terms = 10
lucas_gen = lucas_sequence(n_terms)

print(f"The first {n_terms} Lucas numbers are:")

print(list(lucas_gen))


#code2

def is_perfect_power(n):
    if n <= 0:
        return False
    if n == 1:
        return True
    
    max_a = int(n**0.5)
    
    for a in range(2, max_a + 1):
        if n % a == 0:
            power = a * a
            while power <= n:
                if power == n:
                    return True
                power = power * a
                
    return False


print(f"Is 8 a perfect power? {is_perfect_power(8)}")


#code3

def collatz_length(n):
    if n < 1:
        return 0

    steps = 0
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        steps += 1
    
    return steps

start_num = 6
print(f"The Collatz sequence length for {start_num} is: {collatz_length(start_num)}")


#code4

def polygonal_number(s, n):
   
    if s < 3 or n < 1:
        return None  

    numerator = (s - 2) * (n ** 2) - (s - 4) * n
    
  
    return numerator // 2


print(f"The 5th 3-gonal (triangular) number is: {polygonal_number(3, 5)}")


#code5

def _is_prime(n):

    if n < 2:
        return False
    if n == 2 or n == 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True

def _get_prime_factors(n):
   
    factors = set()
    
   
    if n % 2 == 0:
        factors.add(2)
        while n % 2 == 0:
            n //= 2
            
    
    i = 3
    while i * i <= n:
        if n % i == 0:
            factors.add(i)
            while n % i == 0:
                n //= i
        i += 2
        
  
    if n > 2:
        factors.add(n)
        
    return factors

def is_carmichael(n):
   
   
    if n < 2 or _is_prime(n):
        return False
        
    factors = _get_prime_factors(n)
    
   
    product_of_factors = 1
    for p in factors:
        product_of_factors *= p
        
    if product_of_factors != n:
        return False
        
    
    for p in factors:
        if (n - 1) % (p - 1) != 0:
            return False

#code1

import random
import time

def is_prime_miller_rabin(n, k=20):
   
    
    if n < 2:
        return False
    if n == 2 or n == 3:
        return True
    if n % 2 == 0:
        return False
    

   
    s = 0
    d = n - 1
    while d % 2 == 0:
        d //= 2
        s += 1
    

 
    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, d, n)
        
        
        if x == 1 or x == n - 1:
            continue

       
        for _ in range(s - 1):
            x = (x * x) % n
            if x == 1:
                return False
            
            if x == n - 1:
                break
        else:
            return False
        
            
    return True


st=time.perf_counter()
number1 = 17
result1 = is_prime_miller_rabin(number1)
print(result1)

number2 = 561 
result2 = is_prime_miller_rabin(number2, k=10)
print(result2)
et=time.perf_counter()
duration=et-st
print(f"duration:{duration:.6f}")


#code2

import time
import random 
import math



def modular_pow(base, exponent,modulus):


  
    result = 1

    while (exponent > 0):

    
        if (exponent & 1):
            result = (result * base) % modulus


       
        exponent = exponent >> 1


    
        base = (base * base) % modulus
    
    return result



def pollard_rho(n):


   
    if (n == 1):
        return n


    if (n % 2 == 0):
        return 2



    x = (random.randint(0, 2) % (n - 2))
    y = x


 
    c = (random.randint(0, 1) % (n - 1))


  
    d = 1


 
    while (d == 1):

    
        x = (modular_pow(x, 2, n) + c + n)%n


        y = (modular_pow(y, 2, n) + c + n)%n
        y = (modular_pow(y, 2, n) + c + n)%n


        d = math.gcd(abs(x - y), n)


   
        if (d == n):
            return pollard_rho(n)
    
    return d

st=time.perf_counter()
print("the prime factors of 12 are:",pollard_rho(12))
print("the prime factors of 4 are:",pollard_rho(4))
print("the prime factors of 187 are:",pollard_rho(187))
et=time.perf_counter()
duration=et-st
print(f"duration:{duration:.6f}")



#code3


import time
def zeta_approx(s, terms):
    
    if terms <= 0:
        return 0.0

    zetasum = 0.0
    for n in range(1, terms + 1):
        zetasum += 1.0 / (n ** s)
    return zetasum
st=time.perf_counter()
s_value = 3
num_terms = 1000
approx_zeta = zeta_approx(s_value, num_terms)
print(approx_zeta)
et=time.perf_counter()
duration=et-st
print(f"duration:{duration:.6f}")


#code4

import time

def partitions(n):

    p = [0] * (n + 1)


   
    p[0] = 1

    for i in range(1, n + 1):
        k = 1
        while ((k * (3 * k - 1)) / 2 <= i) :
            p[i] += ((1 if k % 2 else -1) * 
                    p[i - (k * (3 * k - 1)) // 2])

            if (k > 0):
                k *= -1
            else:
                k = 1 - k

    return p[n]

st=time.perf_counter()
print(partitions(7))
print(partitions(20))
print(partitions(11))
et=time.perf_counter()
duration=et-st
print(f"duration:{duration:.6f}")

          
