CODE 1 – Factorial
Write a Python function using recursion to compute the factorial of a non-negative integer n and display sample outputs for 5 and 0.

CODE 2 – Palindrome Number
Write a Python function that checks whether a given integer is a palindrome (reads the same forwards and backwards) and test it on several example numbers, including a negative one.

CODE 3 – Mean of Digits
Write a Python function that computes the arithmetic mean of the digits of a non-negative integer and handles invalid input with a meaningful error message.

CODE 4 – Digital Root
Write a Python function to repeatedly sum the digits of a non-negative integer until a single-digit “digital root” is obtained, and handle negative inputs with an error.

CODE 5 – Abundant Number
Write a Python program to determine whether a given positive integer is an abundant number (sum of its proper divisors is greater than the number) and handle invalid inputs.

CODE 6 – Deficient Number
Write a Python program to determine whether a given positive integer is a deficient number (sum of its proper divisors is less than the number) and handle invalid inputs.

CODE 7 – Harshad Number
Write a Python function that checks whether a positive integer is a Harshad (Niven) number, i.e., divisible by the sum of its digits, and raises errors for invalid inputs.

CODE 8 – Pronic Number
Write a Python program that checks if a positive integer is a pronic number (product of two consecutive integers) and raises an error for invalid inputs.

CODE 9 – Prime Factorization
Write a Python function that returns the list of prime factors (with multiplicity) of an integer greater than 1 and raises an exception for invalid inputs.

CODE 10 – Count Distinct Prime Factors
Write a Python function that counts the number of distinct prime factors of an integer greater than 1 and handles invalid input values with an error.

CODE 11 – Prime Power Check
Write a Python function that determines whether a given integer greater than 1 is a prime power (can be written as  for some prime  and integer ).

CODE 12 – Mersenne Prime Test
Write a Python program that, given an integer , checks whether the Mersenne number  is prime, ensuring that  itself is a prime and handling invalid inputs.

CODE 13 – Twin Primes up to a Limit
Write a Python function that generates all twin prime pairs  up to a given integer limit and raises an error if the limit is not an integer greater than 1.

CODE 14 – Number of Divisors
Write a Python function that counts and returns the total number of positive divisors of a given positive integer, and raises an exception for invalid inputs.

CODE 15 – Aliquot Sum
Write a Python function to compute the aliquot sum of a positive integer (sum of all its proper divisors) and handle invalid inputs with an error.

CODE 16 – Amicable Numbers
Write a Python function that checks whether two positive integers form an amicable pair (each equals the aliquot sum of the other) and rejects invalid inputs.

CODE 17 – Multiplicative Persistence
Write a Python program that computes the multiplicative persistence of a non-negative integer (the number of steps needed to reach a single digit by repeatedly multiplying digits) and handles invalid input.

CODE 18 – Highly Composite Number
Write a Python function that determines whether a positive integer is highly composite, i.e., has more divisors than any smaller positive integer, and handle invalid input values.

CODE 19 – Modular Exponentiation
Write a Python function that efficiently computes  using fast exponentiation and validates all inputs.

CODE 20 – Modular Inverse (Extended Euclidean Algorithm)
Write a Python function that finds the modular multiplicative inverse of a modulo m using the extended Euclidean algorithm, or raises an error if the inverse does not exist.

CODE 21 – Chinese Remainder Theorem (CRT)
Write a Python function that, given lists of remainders and moduli, computes the unique solution modulo the product of the moduli using the Chinese Remainder Theorem, assuming pairwise coprime moduli, and validates all inputs.

CODE 22 – Quadratic Residue Test
Write a Python program that determines whether an integer a is a quadratic residue modulo an odd prime p using Euler’s criterion, and validates that p is an odd prime.

CODE 23 – Multiplicative Order modulo n
Write a Python function to compute the multiplicative order of a modulo n (the smallest positive k such that ), ensuring that a and n are coprime and positive.

CODE 24 – Fibonacci Prime Test
Write a Python function that checks whether a positive integer is both a Fibonacci number and a prime (a Fibonacci prime), with appropriate input validation.

CODE 25 – Lucas Sequence
Write a Python function that generates the first n Lucas numbers (starting with 2 and 1) for a non-negative integer n, and raises an error for invalid inputs.

CODE 26 – Perfect Power Check
Write a Python function that determines whether a positive integer is a perfect power (can be written as  with integers , ), and validates its input.

CODE 27 – Collatz Sequence Length
Write a Python function that computes the number of steps required for a positive integer to reach 1 under the Collatz iteration (3n+1 problem) and handles invalid inputs.

CODE 28 – Polygonal Numbers
Write a Python function to compute the -th -gonal (polygonal) number using the general formula, with input validation for the number of sides s and term n.

CODE 29 – Carmichael Number Test
Write a Python program that checks whether a composite integer greater than 1 is a Carmichael number using Fermat’s little theorem for all a coprime to n, and validates inputs.

CODE 30 – Miller–Rabin Probabilistic Primality Test
Write a Python function that implements the Miller–Rabin primality test to probabilistically determine whether an integer greater than 1 is prime, using k random bases.

CODE 31 – (your missing code, if any)
You can assign this slot to any extra code you have; for example: “Write a Python function to …” (You didn’t paste a separate CODE 31 block in your message.)

CODE 32 – Pollard’s Rho Factorization (Version 1)
Write a Python function that uses Pollard’s Rho algorithm to find a non-trivial factor of a composite integer greater than 1, with basic error handling.

CODE 33 – Pollard’s Rho Factorization (Version 2)
Write a second implementation or demonstration of Pollard’s Rho algorithm to factor composite numbers, reusing a GCD helper and handling invalid inputs.

CODE 34 – Partition Function p(n)
Write a Python function that computes the number of integer partitions of a non-negative integer n using dynamic programming, and validates the input.
